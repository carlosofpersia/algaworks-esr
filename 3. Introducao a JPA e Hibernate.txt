
* Especialista Sprint REST !!!

3. Intrudução a JPA e Hibernate

3.1. Instalando o MySQL Server e MySQL Workbench

	Download do mysql + workbench
		https://dev.mysql.com/downloads/

	Senha do banco de dados mysql: 1234
	
3.2. O que é JPA e Hibernate?
	
	Persistência com banco de dados usando JAVA
		JAVA - Driver JDBC - MySQL;	
		https://blog.algaworks.com/tutorial-jpa/
	
	ORM -> Object Relational Mapper;
		https://www.devmedia.com.br/orm-object-relational-mapper/19056
		ORM (Object Relational Mapper) é uma técnica de mapeamento 
		objeto relacional que permite fazer uma relação dos objetos 
		com os dados que os mesmos representam. 

	* Comunicação é feita através de "metadados (parse)";
	
	JPA é uma específicação, Hibernate é a ferramenta;


3.3. Adicionando JPA e configurando o Data Source

Conteúdo de apoio - Guia do mysql:
	https://dev.mysql.com/doc/connector-j/5.1/en/

Temos um artigo muito bom sobre JPA no nosso blog.
Os exemplos não são usando Spring, por isso você vai notar uma pequena diferença no uso (já que Spring facilita a nossa vida), mas o conteúdo de JPA pode ser um bom complemento no seu conhecimento:
	https://blog.algaworks.com/tutorial-jpa/

Em projetos, ir com o botão direito, em Spring -> Add Starters
	Aqui vc digita "jpa" e apresentará "Spring DATA JPA"; ou adicionar direto pelo artefato do maven no pom.xml

* Add ao pom.xml

	<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa -->
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
		<version>2.1.7.RELEASE</version>
	</dependency>
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<scope>runtime</scope>
	</dependency>
	

* Configurar o "datasource" Em application.properties, 
		devo definir as configurações do mysql:

Mysql: protocol//[hosts][/database][?properties]
	jdbc:mysql://localhost/algafood
	jdbc:mysql://localhost/algafood?createDatabaseIfNotExist=true&serverTimezone=UTC

spring.datasource.url=jdbc:mysql://localhost/algafood?createDatabaseIfNotExist=true&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=1234
	

3.4. Mapeando entidades com JPA

	Entendendo o equals e hashCode
		https://blog.algaworks.com/entendendo-o-equals-e-hashcode/
		
	Tudo que vem do javax.persitence vem da especificação JPA;
	
	Criação das tabelas Cozinha e Restaurante;
/*
@Entity
@Table(name = "tab_cozinhas")
public class Cozinha {

	@Id
	private Long id;

	@Column(name = "nom_cozinha")
	private String nome;
	... 
*/


3.5. Criando as tabelas do banco a partir das entidades (objetos Cozinha e Restaurante)

	Criar entidade direto pela classe é uma prática somente para desenvolvimento,
		Para produção é interessante criar normalmente pelo banco.

	Permite o spring gerar as ddl e 
		o create serve para sempre que rodar a aplicação 
		dropar e criar novamente;

/*
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create
*/

3.6. Mapeando o id da entidade para autoincremento

	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@GeneratedValue(strategy = GenerationType.SEQUENCE)

/*

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;


@Entity
@Table(name = "tab_cozinhas")
public class Cozinha {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
*/

---------------------------------

* Em postgres usamos sequence dessa forma:
	
In PostgreSQL auto-increment is handled using the SERIAL pseudo type. 
	You use this type when you execute CREATE TABLE.
	https://www.postgresql.org/docs/8.4/datatype-numeric.html#DATATYPE-SERIAL
	http://www.neilconway.org/docs/sequences/
	
Now to the point - this SERIAL pseudo type creates a sequence. 
	Autoincrement in PostgreSQL is handled using the created sequence. 
	The default value of the id column becomes: 
	"nextval('your_sequence_name')".
/*
@Id
@SequenceGenerator(name = "users_seq_gen", sequenceName = "users_id_seq", allocationSize=1)
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_seq_gen")
public Long getId() {
     return id;
}
*/

3.7. Importando dados de teste com import.sql

	Para arquivos de massa de teste, 
		devemos criar em resources esse arquivo 
		exatamente com esse nome (import.sql):
		\algafood-api\src\main\resources\import.sql

	Para abrir o arquivo no eclipse, basta selecionar com o botão direito,
		Open with -> Text editor;
	
/*
insert into cozinha (nome, twitter) values ('Tailandesa', '#comidatailandesa');
insert into cozinha (nome, twitter) values ('Indiana', '#comidaindiana');
*/
	
3.8. Consultando objetos do banco de dados

	Criar uma classe para receber os dados do banco, usando as entidades;
		O responsável pela tradução dos sqls é o 
			"javax.persistence.EntityManager injetado com 
			@PersistenceContext + TypedQuery para retorno";
		Uso das queries são em JPQL -> (Linguagem de consulta do JPA) 
/*
	@PersistenceContext
	EntityManager entityManager;
	public List<Cozinha> listar() {
		TypedQuery<Cozinha> query = this.entityManager.createQuery(" from Cozinha ", Cozinha.class);
		// query.setParameter(0, query);
		return query.getResultList();
	}
*/
--------------------------

Usar o spring para um contexto sem ser WEB (usando main por exemplo):
	"AlgafoodApiApplication.class" -> é a fonte primaria das configurações do spring;
	Ainda uso uma chamada de um bean direto pelo applicationContext;
/*
import org.springframework.boot.WebApplicationType;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.context.ApplicationContext;

//aplicação spring não web;
public static void main(String[] args) {
	ApplicationContext applicationContext = 
	new SpringApplicationBuilder(AlgafoodApiApplication.class)
			.web(WebApplicationType.NONE)
			.run(args);

	CadastroCozinha cadastroCozinha = applicationContext.getBean(CadastroCozinha.class);
	List<Cozinha> listCozinha = cadastroCozinha.listar();
	for (Cozinha cozinha : listCozinha) {
		System.out.println(cozinha.getNome());
	}
}
*/

--------------------------

Ver SQL gerado na saída em application.properties
	spring.jpa.show-sql=true

3.9. Adicionando um objeto no banco de dados

	Usar o entity manager com o recurso "merge";
		Este já retorna a instancia com o novo id gerado;
		Preciso usar o @Transactional para iniciar uma nova transação;

/*

import org.springframework.transaction.annotation.Transactional;

@Component
public class CadastroCozinha {
	@Transactional
	public Cozinha salvar (Cozinha cozinha) {
		return entityManager.merge(cozinha);
	}
*/

/*

//aplicação spring não web;
public static void main(String[] args) {
	ApplicationContext applicationContext = new SpringApplicationBuilder(AlgafoodApiApplication.class)
			.web(WebApplicationType.NONE)
			.run(args);
	CadastroCozinha cadastroCozinha = applicationContext.getBean(CadastroCozinha.class);

Cozinha cozinha1 = new Cozinha();
cozinha1.setNome("Brasileira");
cozinha1.setTwitter("#cozinhabrasileira");

Cozinha cozinha2 = new Cozinha();
cozinha2.setNome("Japoneza");
cozinha2.setTwitter("#cozinhajaponeza");

cozinha1 = cadastroCozinha.salvar(cozinha1);
cozinha2 = cadastroCozinha.salvar(cozinha2);

System.out.printf(" %d) %s -> %s", cozinha1.getId(), cozinha1.getNome(), cozinha1.getTwitter());
System.out.println("");
System.out.printf(" %d) %s -> %s", cozinha2.getId(), cozinha2.getNome(), cozinha2.getTwitter());

}

*/

3.10. Buscando um objeto pelo id no banco de dados
	
	usar o metodo "find" especifico a classe e a chave primaria;

/*
	public Cozinha buscarId(Long id) {
		return entityManager.find(Cozinha.class, id);
	}
*/

/*
 * Em BuscaCozinhaMain:
Cozinha cozinha = cadastroCozinha.buscarId(Long.valueOf(2));
*/

3.11. Atualizando um objeto no banco de dados

	* Quando usamos o "merge" -> ele funciona tanto para adicionar 
		ou alterar um registro;

/*
Cozinha cozinha = new Cozinha();
cozinha.setId(Long.valueOf(1));
cozinha.setNome("Tailandesa -> Alterada");
cozinha.setTwitter("#cozinhabrasileira -> Alterada");
cozinha = cadastroCozinha.salvar(cozinha);
*/


3.12. Excluindo um objeto do banco de dados
	Uso do entityManager com "remove + @Transactional";
	
	Artigo JPA (Transações + Estados): 
		https://blog.algaworks.com/tutorial-jpa/

	Ciclo de vida + Estados da transação;
	Detached -> Estado não gerenciado pelo contexto de persistencia JPA;
	Podemos remover esse estado (Detached);
	Transient -> Maneged -> Removed -> (Detached OK);
	Problema: 
		Quando chamo um objeto que não foi Maneged ele da problema de Detached;
	Transient -> (Detached PROBLEM) -> Maneged -> Removed -> (Detached OK);

/*
import org.springframework.transaction.annotation.Transactional;
	@Transactional
	public void remover(Cozinha cozinha) {
		cozinha = buscarId(cozinha.getId());
		entityManager.remove(cozinha);
	}
*/

/*
/ Uso: 
Cozinha cozinha = new Cozinha();
cozinha.setId(Long.valueOf(1));
cadastroCozinha.remover(cozinha);
*/



3.13. Conhecendo o padrão Aggregate do DDD

Artigo sobre Aggregate do Martin Fowler
	https://martinfowler.com/bliki/DDD_Aggregate.html
	
	Aggregate is a pattern in Domain-Driven Design. 
		A DDD aggregate is a cluster of domain objects that can be treated as a single unit. 
		An example may be an order and its line-items, these will be separate objects, 
		but it's useful to treat the order (together with its line items) as a single aggregate.
	An aggregate will have one of its component objects be the aggregate root. 
		Any references from outside the aggregate should only go to the aggregate root. 
		The root can thus ensure the integrity of the aggregate as a whole.
	
Livro azul famoso de DDD
	https://www.amazon.com.br/Domain-Driven-Design-Eric-Evans/dp/8550800651

	Desenvolver software com foco no domínio.
		Agregados são todos os itens que compoem um domínio;
		Aggregate root é a raiz, o pai, a entidade principal;
		Um Aggregado tem somente um Aggregate root (raiz/principal);
		Qualquer referencia de fora do agregado, pode direcionar apenas para o aggregate root

	* Esse Aggregate será implementado com o padrão Repository *
		
3.14. Conhecendo e implementando o padrão Repository

	Um repositório é por aggregado (aggregate de domínio)
	O padrão define não criar repositórios para entidades que não são aggregate root;

	* Pode ser chamado de repositório orientado a persistencia;

	Quem usa o repository não precisa saber sobre a camada de persistencia atraz dele.
	Ele faz a abstração de acessos a dados;
	
1. Cria-se uma interface de repositorio, dentro de "domain";
/*
package com.algaworks.algafood.domain.repository
public interface CozinhaRepository {
	List<Cozinha> todas();
	Cozinha porId(Long id);
	Cozinha adicionar(Cozinha cozinha);
	void remover(Cozinha cozinha);
}
*/

2. Cria-se uma camada de infraestrutura, dentro de "infrastructure" 
	É a parte de implementaçãocomo o repositorio vai conversar com o banco, acesso a e-mail;
	É um componente do Spring (@Component);

-- package com.algaworks.algafood.infrastructure.repository;

@Component
public class CozinhaRepositorioImpl implements CozinhaRepository {

	@PersistenceContext
	EntityManager entityManager;

	@Override
	public Cozinha porId(Long id) {
		return entityManager.find(Cozinha.class, id);
	}
	
	@Override
	public List<Cozinha> todas() {
		
		TypedQuery<Cozinha> query = this.entityManager.createQuery(" from Cozinha ", Cozinha.class);
		// query.setParameter(0, query);
		return query.getResultList();
	}

	@Override
	@Transactional
	public Cozinha adicionar (Cozinha cozinha) {
		return entityManager.merge(cozinha);
	}

	@Override
	@Transactional
	public void remover(Cozinha cozinha) {
		
		cozinha = porId(cozinha.getId());
		entityManager.remove(cozinha);
	}
}


3.15. Conhecendo e usando o Lombok

	https://projectlombok.org/
	https://projectlombok.org/features/all
	https://projectlombok.org/download
	
	Após fazer o downlod escolher um diretório para guardar o lombok.jar
	Rodar-lo diretamente e configurar seu projeto e reinicia-lo:
	cd c/Desenvolvimento/libs
	$ java -jar lombok.jar
	Ele envia um arquivo "lombok.jar" para a raiz do eclipse, e manda para o .m2
	/*
	C:/Users/carlos.dossantos/.m2/repository/org/projectlombok/lombok/(1.18.10|1.18.20|1.18.8);
	C:\Users\carlos.dossantos\Documents\Cast\CEF\Desenvolvimento\siaud-ferramentas\eclipse\lombok.jar;
	C:\Desenvolvimento\sts-4.11.1.RELEASE\lombok.jar;
	*/

/* no pom.xml -> caso de erro, configurar o java, o maven e o lombok corretamente.
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
	<version>1.18.20</version>
	<scope>provided</scope>
</dependency>
*/

Onde eu usar preciso usar as annotations
/*
// import lombok.EqualsAndHashCode;
// import lombok.Getter;
// import lombok.Setter;
import lombok.Data;

// @EqualsAndHashCode
// @Getter
// @Setter
@Data
@Entity
@Table(name = "cozinha")
public class Cozinha {
	...
*/

O @Data usa todos os tipos básicos:
	All together now: A shortcut for @ToString
	, @EqualsAndHashCode, @Getter on all fields
	, and @Setter on all non-final fields
	, and @RequiredArgsConstructor!


@EqualsAndHashCode usa todos os atributos;
	Se eu quiser usar somente um campo, devo usar configurações do "@EqualsAndHashCode":
	E definir no campo qual incluir ou excluir:
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
* @EqualsAndHashCode.Include *

/*
@Getter
@Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@Entity
public class Restaurante {

	@EqualsAndHashCode.Include
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	....
*/

3.16. Desafio: Lombok e repositório de restaurantes

	Somente fazer o repositorio de restaurantes e suas implementações;

3.17. Mapeando relacionamento com @ManyToOne

	Colocar o ENGINE "InnoDB" do mysql setando na mão o Dialect em application.properties
	// spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
/*
	@ManyToOne
	private Cozinha cozinha;
*/

3.18. A anotação @JoinColumn
	// @JoinColumn(name = "cozinha_id")
/*
	@ManyToOne
	@JoinColumn(name = "cozinha_id")
	private Cozinha cozinha;
*/
	
3.19. Propriedade nullable de @Column e @JoinColumn

	@Column(nullable = false)
	private String nome;
	
	@Column(name = "nome", nullable = false)
	private String nome;

	@ManyToOne
	@JoinColumn(name = "cozinha_id", nullable = false)
	private Cozinha cozinha;
	
	@Column(name = "twitter", length = 140)
	private String twitter;	

3.20. Desafio: mapeando entidades
		* Forma Pagamento;
		* Permissao;
		* Estado e Cidade;

Ex:
	com.algaworks.algafood.domain.model (Restaurante);
	com.algaworks.algafood.domain.repository (RestauranteRepository);
	com.algaworks.algafood.infrastructure.repository (RestauranteRepositorioImpl);
	com.algaworks.algafood.jpa (ConsultaRestauranteMain);
	
----------------------
	
FIM.


************************************************************************************

@Getter
@Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@Entity
public class Restaurante {

	@EqualsAndHashCode.Include
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	@Column(nullable = false)
	private String nome;
	
	@Column(name = "taxa_frete", nullable = false)
	private BigDecimal taxaFrete;

	@ManyToOne
	@JoinColumn(name = "cozinha_id", nullable = false)
	private Cozinha cozinha;
}

************************************************************************************

* pom.xml (completo)


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.7.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.algaworks</groupId>
	<artifactId>algafood-api</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>algafood-api</name>
	<description>API de delivery de comida</description>
	<properties>
		<java.version>12</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
	    <dependency>
	    	<groupId>org.projectlombok</groupId>
	    	<artifactId>lombok</artifactId>
	    	<version>1.18.20</version>
	    	<scope>provided</scope>
	    </dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

**********************************************

* application.properties

server.port = 8087
spring.datasource.url=jdbc:mysql://localhost/algafood?createDatabaseIfNotExist=true&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=1234
spring.jpa.open-in-view=false
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect


**********************************************
* import.sql

insert into cozinha (id, nome, twitter) values (1, 'Tailandesa', '#comidatailandesa');
insert into cozinha (id, nome, twitter) values (2, 'Indiana', '#comidaindiana');
insert into cozinha (id, nome, twitter) values (3, 'Alemanha', '#comidaalemanha');

insert into restaurante (id, nome, taxa_frete, cozinha_id) values (1, 'Restaurante da Tailandia', '3.70', 1);
insert into restaurante (id, nome, taxa_frete, cozinha_id) values (2, 'Thai Gourmet', '3.71', 1);
insert into restaurante (id, nome, taxa_frete, cozinha_id) values (3, 'Thai Delivery', '3.72', 1);
insert into restaurante (id, nome, taxa_frete, cozinha_id) values (4, 'Restaurante do Indiano', '2.70', 2);
insert into restaurante (id, nome, taxa_frete, cozinha_id) values (5, 'Restaurante da Alemanha', '1.70', 3);

insert into estado (id, nome) values (1, 'Minas Gerais');
insert into estado (id, nome) values (2, 'São Paulo');
insert into estado (id, nome) values (3, 'Ceará');

insert into cidade (id, nome, estado_id) values (1, 'Uberlândia', 1);
insert into cidade (id, nome, estado_id) values (2, 'Belo Horizonte', 1);
insert into cidade (id, nome, estado_id) values (3, 'São Paulo', 2);
insert into cidade (id, nome, estado_id) values (4, 'Campinas', 2);
insert into cidade (id, nome, estado_id) values (5, 'Fortaleza', 3);

insert into forma_pagamento (id, descricao) values (1, 'Cartão de crédito');
insert into forma_pagamento (id, descricao) values (2, 'Cartão de débito');
insert into forma_pagamento (id, descricao) values (3, 'Dinheiro');

insert into permissao (id, nome, descricao) values (1, 'CONSULTAR_COZINHAS', 'Permite consultar cozinhas');
insert into permissao (id, nome, descricao) values (2, 'EDITAR_COZINHAS', 'Permite editar cozinhas');




    